//go:generate go run ./var_gen.go

package main

import (
	"os"
	"os/exec"
	"sort"
	"strings"
	"text/template"

	"github.com/gobuffalo/flect"
)

type Var struct {
	Name string
	// GenerateAccessor tells the generator to generate an access func for the
	// variable so a custom one can be written.
	GenerateAccessor bool

	// Desc provides a description to annotate docs and generated access funcs
	Desc string
}

type Vars []Var

func (v Vars) Len() int {
	return len(v)
}

func (v Vars) Less(i, j int) bool {
	return v[i].Name < v[j].Name
}

func (v Vars) Swap(i, j int) {
	v[i], v[j] = v[j], v[i]
}

var vars = Vars{
	{Name: "Application", Desc: "If provided, name of the (sub)application to compile"},
	{Name: "DeployDockerHost", Desc: "DOCKER_HOST environment variable to use while deploying"},
	{Name: "DockerComposeFile", Desc: "Path to a docker-compose.yaml file to deploy"},
	{Name: "DockerContext", Desc: "Context of the docker build, defaults to root of the project", GenerateAccessor: true},
	{Name: "Dockerfile", Desc: "Dockerfile to use in docker build, defaults `Dockerfile` in the context directory (like docker does)", GenerateAccessor: true},
	{Name: "Domain", Desc: "Domain name to deploy the stack to. This will be passed to the environment when doing the docker deploy, so the compose file can reference this appropriately."},
	{Name: "Environment", Desc: "Environment to deploy to. \"review\", \"staging\", \"production\" are defaults, but any string may be used."},
	{Name: "GitDefaultBranch", Desc: "Target branch for PRs/MRs. Defaults to master."},
	{Name: "Image", Desc: "Docker image path to push to after build", GenerateAccessor: true},
	{Name: "Registry", Desc: "Docker registry to log into before pushing", GenerateAccessor: true},
	{Name: "RegistryPassword", Desc: "Password to use to log into Docker registry", GenerateAccessor: true},
	{Name: "RegistryUsername", Desc: "Username to use to log into Docker registry", GenerateAccessor: true},
	{Name: "StackName", Desc: "", GenerateAccessor: true},
	{Name: "Variant", Desc: "Variant build of the application. This is helpful for situations where one application is deployed with different builds for different settings."},
	{Name: "Version", Desc: "Version of the application being built/deployed"},
}

var t = template.Must(template.New("").Parse(`
// DO NOT EDIT: This file is generated by var_gen.go

package beluga

const (
	{{- range .}}
	{{ .VarName }} = "{{ .EnvName }}"
	{{- end }}
)

var knownVarNames = []string{
	{{range .}}
	{{- .VarName }},
{{end}} }

{{ range .}}
{{- if .GenerateAccessor }}
{{.Comment}}
func (e Environment) {{ .GoName }}() string {
	return e[{{ .VarName }}]
}
{{ end -}}
{{ end }}
`))

var mt = template.Must(template.New("").Parse(`
<!-- DO NOT EDIT: This file is generated by var_gen.go -->

# Beluga Environment Variables

The following environment variables can be set to override the default functionality of beluga.

| Name | Description |
| ---- | ----------- |
{{- range .}}
| {{ .EnvName }} | {{ .Desc }} |
{{- end -}}
`))

func templateToFile(t *template.Template, filename string) error {
	output, err := os.Create(filename)
	if err != nil {
		return err
	}
	err = t.Execute(output, vars)
	if err != nil {
		return err
	}
	err = output.Close()
	if err != nil {
		return err
	}
	return nil
}

func main() {
	sort.Sort(vars)
	const filename = "../../var.go"

	err := templateToFile(t, filename)
	if err != nil {
		panic(err)
	}
	err = templateToFile(mt, "../../docs/variables.md")
	if err != nil {
		panic(err)
	}

	err = exec.Command("go", "fmt", filename).Run()
	if err != nil {
		panic(err)
	}
}

func (v Var) GoName() string {
	return flect.Pascalize(v.Name)
}

func (v Var) VarName() string {
	return "var" + flect.Pascalize(v.Name)
}

func (v Var) EnvName() string {
	return "BELUGA_" + strings.ToUpper(flect.Underscore(v.Name))
}

func (v Var) Comment() string {
	if v.Desc == "" {
		return ""
	}
	const maxLength = 80 - 3 // 3 chars for comment
	comment := "//"
	lineLength := 0
	for _, word := range strings.Split(v.Desc, " ") {
		lineLength += len(word) + 1
		if lineLength >= maxLength {
			comment += "\n// " + word
			lineLength = len(word) + 1
		} else {
			comment += " " + word
		}
	}
	return comment
}
